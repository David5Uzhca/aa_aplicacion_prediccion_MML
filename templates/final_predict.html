<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Predicción de Stock (Dev)</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <h1>Predicción de Stock de Supermercado</h1>
    <hr>
    <h2>Opciones de Predicción</h2>
    
    <fieldset>
        <legend>Tipo de Predicción:</legend>
        <label>
            <input type="radio" name="prediction_type" id="radio_unitario" value="unitario" checked>
            Predicción Unitaria (por Producto)
        </label>
        <br>
        <label>
            <input type="radio" name="prediction_type" id="radio_general" value="general">
            Predicción General (Todos los 30 Productos)
        </label>
    </fieldset>

    <br>

    <label for="input_date">Fecha de Predicción (YYYY-MM-DD):</label>
    <input type="date" id="input_date" value="" required> 
    <span style="font-size: 0.8em; color: gray;">(Por defecto, hoy)</span>
    
    <br><br>

    <div id="product_id_container">
        <label for="input_product_id">ID del Producto:</label>
        <select id="input_product_id" required>
            </select>
        <span style="font-size: 0.8em; color: gray;">(Ej: pdct0001)</span>
    </div>
    <br>
    <button id="predict_button">Predecir Stock</button> 
    <hr>
    <h2>Resultados de la Predicción</h2>
    <div id="loading_message" style="color: blue; display: none;">Cargando... esto podría tardar si la predicción es a muchos días.</div>

    <table border="1" id="results_table" style="width: 100%; border-collapse: collapse;">
        <thead>
            <tr>
                <th>ID Producto</th>
		<th>Nombre del Producto</th>
                <th>Fecha Predicha</th>
                <th>Stock Predicho</th>
                <th>Necesita Reabastecer</th>
            </tr>
        </thead>
        <tbody id="results_body">
            <tr><td colspan="4">Haz clic en 'Predecir Stock' para ver los resultados.</td></tr>
        </tbody>
    </table>
    <hr>

    <button id="update_model_button">Añadir Datos y Actualizar Modelo</button>
    
    <button id="import_data_button">Importar Datos Externos</button>
    <input type="file" id="csv_upload" accept=".csv" style="display: none;">
    <p style="font-size: 0.8em; color: var(--color-secondary); margin-top: 5px;">
        El CSV debe contener: ID del producto (product_id) - Fecha de creacion (created_at) - Cantidad actual (quantity_on_hand)
    </p>

    <h3>Reentrenamiento</h3>
    <pre id="retrain_log" style="background-color: #f4f4f4; border: 1px solid #ccc; padding: 10px; max-height: 200px; overflow-y: scroll;"></pre>

    <hr>
    
    <h2>Reporte</h2>
    <div id="conclusion_loading" style="color: blue; display: none;">Analizando resultados con Gemini...</div>
    <div id="conclusion_box" style="background-color: #f0f8ff; border: 1px solid #aad8f8; padding: 15px; margin-top: 10px; white-space: pre-wrap; min-height: 100px;">
        Haz una predicción para generar el análisis.
    </div>

<script>
    // === 1. DEFINICIÓN DE VARIABLES ESENCIALES ===
    const unitarioRadio = document.getElementById('radio_unitario');
    const generalRadio = document.getElementById('radio_general');
    const productIdContainer = document.getElementById('product_id_container');
    const resultsBody = document.getElementById('results_body');
    const predictButton = document.getElementById('predict_button');
    const loadingMessage = document.getElementById('loading_message');
    const updateModelButton = document.getElementById('update_model_button');
    const importDataButton = document.getElementById('import_data_button');
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('input_date').value = today;

    // Carga de IDs (El backend asegura que sea una lista cruda separada por comas)
    const products_list_raw = '{{ products_json }}'; 
    const productIds = products_list_raw ? products_list_raw.split(',').map(id => id.trim()) : [];
    
    console.log("IDs de producto cargados:", productIds.length, productIds);
    const productSelect = document.getElementById('input_product_id');

    // === 2. FUNCIONES FALTANTES Y PRINCIPALES ===

    function populateProductSelect() {
        if (productIds.length === 0 || (productIds.length === 1 && productIds[0] === '')) {
             const option = document.createElement('option');
             option.textContent = "No hay productos disponibles";
             productSelect.appendChild(option);
             return;
        }
        productIds.forEach(id => {
            const option = document.createElement('option');
            option.value = id;
            option.textContent = id;
            productSelect.appendChild(option);
        });
    }

    // --- FUNCIÓN FALTANTE 1: Manejar el tipo de predicción ---
    function handlePredictionTypeChange() {
        if (unitarioRadio.checked) {
            productIdContainer.style.display = 'block';
        } else {
            productIdContainer.style.display = 'none';
        }
    }

    // --- FUNCIÓN FALTANTE 2: Lógica de la predicción ---
    async function runPrediction() {
        resultsBody.innerHTML = '';
        loadingMessage.style.display = 'block';
        predictButton.disabled = true;

        const date = document.getElementById('input_date').value;
        const isUnitario = unitarioRadio.checked;
        let url, body;

        // Determinar el endpoint de la API
        if (isUnitario) {
            const productId = productSelect.value;
            url = '/api/predict'; 
            body = { product_id: productId, date: date };
        } else {
            url = '/api/restock'; 
            body = { date: date, threshold: 20.0 };
        }

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });

            if (!response.ok) {
                const error = await response.json();
                resultsBody.innerHTML = `<tr><td colspan="4" style="color: red;">Error API ${response.status}: ${error.detail || 'Error desconocido'}</td></tr>`;
                return;
            }

            let data = await response.json();
            
            if (isUnitario) {
                data = [data];
            }

            displayResults(data);
	    
	    await generateConclusion();

        } catch (error) {
            resultsBody.innerHTML = `<tr><td colspan="4" style="color: red;">Error de conexión: ${error.message}</td></tr>`;
        } finally {
            loadingMessage.style.display = 'none';
            predictButton.disabled = false;
        }
    }
    
    // --- FUNCIÓN FALTANTE 3: Mostrar resultados ---
    function displayResults(data) {
        if (data.length === 0) {
            resultsBody.innerHTML = '<tr><td colspan="5">No se encontraron resultados para la fecha y/o producto especificado.</td></tr>';
            return;
        }

        resultsBody.innerHTML = ''; 
        
        data.forEach(item => {
            const stock = Math.max(0, parseFloat(item.quantity_on_hand)).toFixed(2);
            
            // Determinar si necesita reabastecimiento (asumiendo 20.0 de umbral)
            const needsRestockStatus = item.needs_restock !== undefined 
                                       ? item.needs_restock 
                                       : (parseFloat(stock) <= 20.0);

            const needsRestockText = needsRestockStatus ? 'SÍ' : 'NO';
            
	    const row = `
		 <tr>
		 <td>${item.product_id}</td>        <td>${item.product_name}</td>      <td>${item.fecha_predicha}</td>    <td>${stock}</td>                  <td style="font-weight: bold;">${needsRestockText}</td> </tr>
   	   `;

            resultsBody.innerHTML += row;
        });
    }



// --- Función para recolectar datos de la tabla (CORREGIDA) ---
function getTableData() {
    const data = [];
    const rows = resultsBody.querySelectorAll('tr');
    
    rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        
        if (cells.length !== 5) { 
            return;
        }

	const pid = cells[0].textContent.trim();
        const stock = parseFloat(cells[3].textContent);
        
        if (pid === '' || isNaN(stock)) {
            return;
        }
        
        const needsRestockText = cells[4].textContent.trim(); 
        const needsRestock = needsRestockText.includes('SÍ');

        data.push({
            product_id: cells[0].textContent.trim(),
            product_name: cells[1].textContent.trim(), 
            fecha_predicha: cells[2].textContent.trim(), 
            quantity_on_hand: parseFloat(cells[3].textContent), 
            needs_restock: needsRestock 
        });
    });

    return data;
}

// --- Lógica para generar la Conclusión con IA ---
async function generateConclusion() {
    const tableData = getTableData(); 
    const conclusionBox = document.getElementById('conclusion_box');
    const conclusionLoading = document.getElementById('conclusion_loading');
    
    if (tableData.length === 0 || tableData[0].product_id === 'Haz clic en '){
        conclusionBox.textContent = "No hay resultados para analizar.";
        return;
    }

    // Limpiar el contenido y mostrar carga
    conclusionBox.textContent = "Generando análisis...";
    conclusionLoading.style.display = 'block';

    try {
        const response = await fetch('/api/conclusion', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ results: tableData })
        });

        const result = await response.json();

        if (!response.ok) {
            conclusionBox.textContent = `❌ ERROR en el análisis de IA: ${result.detail || 'Fallo desconocido'}`;
        } else {
            conclusionBox.textContent = result.conclusion;
        }

    } catch (error) {
        conclusionBox.textContent = `❌ Error de red al contactar al asistente: ${error.message}`;
    } finally {
        conclusionLoading.style.display = 'none';
    }
}



    // --- Lógica del botón de Reentrenamiento ---
    async function startRetraining() {
        const tableData = getTableData();
        const retrainLog = document.getElementById('retrain_log');
        
        if (tableData.length === 0 || tableData[0].product_id === 'Haz clic en '){
            retrainLog.textContent = "ERROR: La tabla de resultados está vacía. Primero realiza una predicción.";
            return;
        }

        retrainLog.textContent = `Preparando ${tableData.length} filas para añadir y reentrenar...\n`;
        updateModelButton.disabled = true;
        updateModelButton.textContent = "Procesando...";

        try {
            const response = await fetch('/api/retrain', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(tableData)
            });

            const result = await response.json();

            if (!response.ok) {
                retrainLog.textContent += `\nERROR: ${result.detail || 'Fallo desconocido'}`;
            } else {
                // El resultado contiene el log completo del backend
                retrainLog.textContent = result.log;
                retrainLog.style.backgroundColor = '#e6ffe6'; // Verde claro para éxito
            }

        } catch (error) {
            retrainLog.textContent += `\nError de red al contactar al servidor: ${error.message}`;
            retrainLog.style.backgroundColor = '#ffe6e6'; // Rojo claro para error
        } finally {
            updateModelButton.disabled = false;
            updateModelButton.textContent = "Añadir Datos y Actualizar Modelo";
        }
    }
    
    async function startCsvUpload() {
        const csvUploadInput = document.getElementById('csv_upload');
        const importDataButton = document.getElementById('import_data_button');
        const retrainLog = document.getElementById('retrain_log');
        csvUploadInput.click();
        csvUploadInput.onchange = async () => {
            const file = csvUploadInput.files[0];
            if (!file) return;

            retrainLog.textContent = `Archivo seleccionado: ${file.name}. Preparando subida...\n`;
            importDataButton.disabled = true;
            importDataButton.textContent = "Procesando CSV...";

            // Usar FormData para enviar el archivo
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/upload_and_retrain', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (!response.ok) {
                    retrainLog.textContent = result.detail.log || `ERROR: Fallo desconocido del servidor.`;
                    retrainLog.style.backgroundColor = '#ffe6e6';
                } else {
                    retrainLog.textContent = result.log;
                    retrainLog.style.backgroundColor = '#e6ffe6';
                }

            } catch (error) {
                retrainLog.textContent += `\nError de red: No se pudo conectar al servidor.`;
                retrainLog.style.backgroundColor = '#ffe6e6';
            } finally {
                importDataButton.disabled = false;
                importDataButton.textContent = "Importar Datos Externos";
                csvUploadInput.value = ''; 
            }
        };
    }
 
    importDataButton.addEventListener('click', startCsvUpload);
    updateModelButton.addEventListener('click', startRetraining);

    populateProductSelect();
    handlePredictionTypeChange(); 
    
    unitarioRadio.addEventListener('change', handlePredictionTypeChange);
    generalRadio.addEventListener('change', handlePredictionTypeChange);
    predictButton.addEventListener('click', runPrediction);

</script>

</body>
</html>
